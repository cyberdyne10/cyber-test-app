<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cyber Test – Test</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="style.css">
  <style>
    .q-image { max-width: 100%; height: auto; border-radius: 8px; margin: 10px 0; border: 1px solid #334155; }
    .badge-practice { background: #8b5cf6; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.7em; }
      .question-active { outline: 2px solid rgba(56,189,248,0.55); box-shadow: 0 0 0 4px rgba(56,189,248,0.08); border-radius: 12px; }
    .conn-green { color:#22c55e; }
    .conn-amber { color:#f59e0b; }
    .conn-red { color:#ef4444; }

    /* Navigator button states */
    .qnav-btn {
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(2,6,23,0.35);
      color: #e2e8f0;
      font-weight: 700;
      font-size: 0.82rem;
      padding: 8px 0;
      line-height: 1;
    }
    .qnav-btn:hover { border-color: rgba(56,189,248,0.55); }
    .qnav-answered { background: rgba(56,189,248,0.15); border-color: rgba(56,189,248,0.55); }
    .qnav-flagged { box-shadow: inset 0 0 0 2px rgba(245,158,11,0.85); }
    .qnav-active { outline: 2px solid rgba(99,102,241,0.65); }

    .flag-btn {
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(2,6,23,0.20);
      color: #e2e8f0;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.78rem;
      font-weight: 700;
    }
    .flag-btn.flagged {
      border-color: rgba(245,158,11,0.75);
      background: rgba(245,158,11,0.15);
      color: #fde68a;
    }

    /* Mobile polish */
    @media (max-width: 992px) {
      #qNav { grid-template-columns: repeat(8, minmax(0, 1fr)); }
    }
    @media (max-width: 576px) {
      #qNav { grid-template-columns: repeat(6, minmax(0, 1fr)); }
      #bottomActionBar {
        position: sticky;
        bottom: 0;
        background: rgba(15,23,42,0.92);
        padding: 10px 10px;
        border-radius: 14px;
        border: 1px solid rgba(148,163,184,0.18);
        backdrop-filter: blur(8px);
      }
    }
  </style>
</head>
<body>
  <div class="main-shell">
    <div class="futuristic-orb"></div>

    <div class="panel-glass">
      <div class="panel-header mb-3">
        <div>
          <div class="badge-chip">Active Assessment</div>
          <div class="panel-title mt-2">
            <span>Cyber</span><span class="accent">Challenge</span>
          </div>
          <div id="info" class="panel-subtitle"></div>
          <div class="d-flex align-items-center gap-2 flex-wrap" style="margin-top:6px;">
            <span id="testTypeBadge" class="badge" style="background:#0ea5e9;">EXAM</span>
            <span id="testTypeTip" class="text-muted" style="font-size:0.8rem;"></span>
            <span id="connStatus" class="ms-auto" style="font-size:0.8rem; padding:2px 8px; border-radius:999px; border:1px solid rgba(148,163,184,0.25);">● Checking…</span>
          </div>
          <div id="sessionProgressWrap" class="mt-2" style="display:none;">
            <div class="progress" style="height:10px; background:rgba(148,163,184,0.15);">
              <div id="sessionProgressBar" class="progress-bar" role="progressbar" style="width:0%; background:linear-gradient(90deg,#38bdf8,#f97316);"></div>
            </div>
          </div>
          <div id="antiCheatNotice" class="panel-subtitle" style="font-size:0.8rem; color:#facc15; margin-top:4px;">
            Do not close this tab or switch windows unnecessarily; activity may be recorded.
          </div>
        </div>
        <div class="text-end">
          <div class="timer-label mb-1">Session Timer</div>
          <div class="timer-large" id="timer">--:--</div>
          <div id="saveStatus" class="text-muted" style="font-size:0.8rem; margin-top:6px;">Not saved yet</div>
        </div>
      </div>

      <div class="row g-3 mt-3">
        <div class="col-lg-8">
          <form id="testForm"></form>
        </div>
        <div class="col-lg-4">
          <div class="card" style="background: rgba(15,23,42,0.65); border: 1px solid rgba(148,163,184,0.22); border-radius: 14px;">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <div class="fw-semibold">Questions</div>
                <div class="text-muted" style="font-size:0.85rem;"><span id="answeredCount">0</span>/<span id="totalCount">0</span> answered</div>
              </div>
              <div class="d-flex justify-content-between align-items-center mb-2">
                <div class="text-muted" style="font-size:0.85rem;">Flagged: <span id="flaggedCount">0</span></div>
                <button id="jumpFirstUnanswered" type="button" class="btn btn-sm btn-outline-info">First Unanswered</button>
              </div>
              <div id="qNav" style="display:grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap: 8px;"></div>
              <div class="text-muted mt-3" style="font-size:0.8rem; line-height:1.35;">
                Tip: click a number to jump. Use N/P to move, A–D or 1–4 to answer.
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="d-flex justify-content-between align-items-center mt-4 btn-row-stack" id="bottomActionBar">
        <div class="text-muted small">The test will auto-submit when the timer reaches zero.</div>
        <button id="submitBtn" type="button" class="btn btn-fx-primary">
          <span class="pulse-dot"></span>
          <span>Submit Answers</span>
        </button>
      </div>

      <div id="result" class="result-banner mt-3" style="display:none;">
        <div class="d-flex justify-content-between align-items-center mb-3">
          <span id="scoreText"></span>
        </div>
        <div id="nextExamNotice" class="text-info mb-2" style="display:none; font-size:0.85rem;"></div>
        <div class="text-center border-top pt-3" style="border-color: rgba(255,255,255,0.1) !important;">
          <button id="finishLogoutBtn" class="btn btn-sm btn-outline-danger">Logout & Return Home</button>
        </div>
      </div>
      <div id="review" class="mt-3" style="display:none;"></div>
    </div>
  </div>

  <footer class="text-center text-muted" style="font-size:0.75rem; margin-top:1rem; opacity:0.7;">
    Cyber-Logic Network Exam System • v1.0 • Privacy &amp; Terms (internal use)
  </footer>

  <script>
    const params = new URLSearchParams(window.location.search);
    const studentName = params.get('name');
    const studentId = params.get('id');
    const dbId = params.get('db_id'); 
    const testId = params.get('test');
    const sessionMode = params.get('session'); // e.g. 'full'
    const sessionOrder = params.get('order');  // comma-separated test ids
    let attemptId = null;
    let isPractice = false;

    const urlAttemptId = params.get('attempt');
    if (urlAttemptId) {
      const n = parseInt(urlAttemptId, 10);
      if (Number.isFinite(n) && n > 0) attemptId = n;
    }

    function setSaveStatus(text, color) {
      const el = document.getElementById('saveStatus');
      if (!el) return;
      el.textContent = text;
      el.style.color = color || '';
    }

    function serializeAnswers() {
      const out = [];
      document.querySelectorAll('[name^="q_"]').forEach(el => {
        if (el.checked) {
          const questionId = el.name.substring(2);
          out.push({ question_id: parseInt(questionId, 10), option_id: parseInt(el.value, 10) });
        }
      });
      return out;
    }

    const infoEl = document.getElementById('info');
    const isFullSession = sessionMode === 'full' && sessionOrder;
    let headerMeta = `Candidate: ${studentName} ${studentId ? '(' + studentId + ')' : ''}`;
    if (isFullSession) {
      const ids = sessionOrder.split(',').map(x => parseInt(x, 10)).filter(Boolean);
      const currentIndex = ids.indexOf(parseInt(testId, 10));
      const position = currentIndex >= 0 ? currentIndex + 1 : 1;
      const total = ids.length || 1;
      headerMeta += ` \u2022 Exam ${position} of ${total} \u2022 You are in a full session. All exams will run back-to-back.`;
    }
    infoEl.textContent = headerMeta;

    // Anti-Cheating: Detect Blur
    window.addEventListener('blur', () => {
      if (attemptId && !isPractice) {
        fetch(`/api/attempts/${attemptId}/violation`, { method: 'POST' });
        console.log('Violation recorded: Window blur');
      }
    });

    async function loadQuestions() {
      // 1. Notify Start (Live Monitor)
      const startRes = await fetch(`/api/tests/${testId}/start`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ student_name: studentName, student_id: studentId, student_db_id: dbId })
      });
      const startData = await startRes.json();
      attemptId = startData.attempt_id;

      // Persist attempt id in URL for resume
      if (attemptId) {
        try {
          const u = new URL(window.location.href);
          u.searchParams.set('attempt', String(attemptId));
          history.replaceState(null, '', u.toString());
        } catch(e) {}
      }

      // 2. Load Questions
      const res = await fetch(`/api/tests/${testId}/full`);
      const data = await res.json();
      
      let questions = data.questions || [];
      const config = data.test_config || {};
      isPractice = config.type === 'practice';

      // Test type badge
      const badge = document.getElementById('testTypeBadge');
      const tip = document.getElementById('testTypeTip');
      const type = (config.type || 'exam').toLowerCase();
      const map = {
        exam: { label: 'EXAM', tip: 'Exam attempts are recorded.' , color:'#0ea5e9'},
        practice: { label: 'PRACTICE', tip: "Practice doesn't affect records.", color:'#8b5cf6'},
        mock: { label: 'MOCK', tip: 'Mock simulates exam conditions.', color:'#22c55e'}
      };
      const meta = map[type] || { label: String(type).toUpperCase(), tip: '', color:'#0ea5e9' };
      if (badge) { badge.textContent = meta.label; badge.style.background = meta.color; badge.title = meta.tip; }
      if (tip) tip.textContent = meta.tip;

      // Full session progress bar
      if (isFullSession) {
        const wrap = document.getElementById('sessionProgressWrap');
        const bar = document.getElementById('sessionProgressBar');
        if (wrap && bar) {
          wrap.style.display = 'block';
          const ids = sessionOrder.split(',').map(x => parseInt(x, 10)).filter(Boolean);
          const currentIndex = ids.indexOf(parseInt(testId, 10));
          const pos = currentIndex >= 0 ? currentIndex + 1 : 1;
          const total = ids.length || 1;
          const pct = Math.round((pos / total) * 100);
          bar.style.width = pct + '%';
          bar.setAttribute('aria-valuenow', String(pct));
          bar.setAttribute('aria-valuemin', '0');
          bar.setAttribute('aria-valuemax', '100');
        }
      }

      if (isPractice) {
        document.getElementById('timer').textContent = 'PRACTICE';
        document.querySelector('.badge-chip').textContent = 'Practice Mode';
      } else {
        startTimer(config.duration_minutes || 30);
      }

      const form = document.getElementById('testForm');
      form.innerHTML = '';

      questions.forEach((q, idx) => {
        const container = document.createElement('div');
        container.className = 'question-block mb-3';

        const titleRow = document.createElement('div');
        titleRow.className = 'question-title';
        const idxEl = document.createElement('div');
        idxEl.className = 'question-index';
        idxEl.textContent = `Q${idx + 1}`;
        const textEl = document.createElement('div');
        textEl.className = 'question-text';
        textEl.innerHTML = q.text + (q.marks > 1 ? ` [${q.marks} pts]` : '');
        
        titleRow.appendChild(idxEl);
        titleRow.appendChild(textEl);
        container.appendChild(titleRow);

        if (q.image_url) {
          const img = document.createElement('img');
          img.src = q.image_url;
          img.className = 'q-image';
          container.appendChild(img);
        }

        const optWrapper = document.createElement('div');
        q.options.forEach((o, optIdx) => {
          const label = document.createElement('label');
          label.className = 'option-pill mb-2';
          const input = document.createElement('input');
          input.type = q.question_type === 'multiple' ? 'checkbox' : 'radio';
          input.name = 'q_' + q.id;
          input.value = o.id;
          input.style.marginRight = '8px'; // Spacing
          
          // Instant Feedback for Practice Mode
          if (isPractice) {
            input.addEventListener('change', () => {
              // Highlight immediately
              // We don't have is_correct here to prevent cheating in source, 
              // but practice mode implies learning. 
              // Actually, server still hides correct flag. 
              // To show instant feedback, we'd need to fetch check. 
              // For simplicity, Practice Mode behaves like exam but untimed.
            });
          }

          const key = document.createElement('span');
          key.className = 'option-key';
          key.textContent = String.fromCharCode(65 + optIdx);
          const textNode = document.createElement('span');
          textNode.textContent = o.text;

          label.appendChild(input);
          label.appendChild(key);
          label.appendChild(textNode);
          optWrapper.appendChild(label);
        });

        container.appendChild(optWrapper);
        form.appendChild(container);
      });

      // Build navigator + answered/flag state
      const flagged = new Set();

      function isQuestionAnswered(questionId) {
        const inputs = Array.from(document.querySelectorAll('[name="q_' + questionId + '"]'));
        return inputs.some(i => i.checked);
      }

      function updateCountsAndNav() {
        const totalCountEl = document.getElementById('totalCount');
        const answeredCountEl = document.getElementById('answeredCount');
        const flaggedCountEl = document.getElementById('flaggedCount');
        if (totalCountEl) totalCountEl.textContent = String(questions.length);

        let answered = 0;
        questions.forEach(q => { if (isQuestionAnswered(q.id)) answered++; });
        if (answeredCountEl) answeredCountEl.textContent = String(answered);
        if (flaggedCountEl) flaggedCountEl.textContent = String(flagged.size);

        questions.forEach((q, i) => {
          const btn = document.getElementById('qnav_' + i);
          if (!btn) return;
          btn.classList.toggle('qnav-answered', isQuestionAnswered(q.id));
          btn.classList.toggle('qnav-flagged', flagged.has(q.id));
          btn.classList.toggle('qnav-active', i === _activeQ);
        });
      }

      function buildNavigator() {
        const nav = document.getElementById('qNav');
        if (!nav) return;
        nav.innerHTML = '';

        questions.forEach((q, i) => {
          const b = document.createElement('button');
          b.type = 'button';
          b.id = 'qnav_' + i;
          b.className = 'qnav-btn';
          b.textContent = String(i + 1);
          b.title = 'Jump to Q' + (i + 1);
          b.addEventListener('click', () => setActiveQuestion(i));
          nav.appendChild(b);
        });

        const jumpBtn = document.getElementById('jumpFirstUnanswered');
        if (jumpBtn) {
          jumpBtn.onclick = () => {
            const first = questions.findIndex(q => !isQuestionAnswered(q.id));
            setActiveQuestion(first >= 0 ? first : 0);
          };
        }

        updateCountsAndNav();
      }

      // Attach per-question flag buttons
      function attachFlagButtons() {
        const blocks = getQuestionBlocks();
        blocks.forEach((block, i) => {
          const q = questions[i];
          if (!q) return;
          const titleRow = block.querySelector('.question-title');
          if (!titleRow) return;
          if (titleRow.querySelector('.flag-btn')) return;

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'flag-btn';
          btn.textContent = 'Review';
          btn.title = 'Mark this question to review later';

          const refresh = () => {
            const isF = flagged.has(q.id);
            btn.classList.toggle('flagged', isF);
            btn.textContent = isF ? 'Flagged' : 'Review';
          };

          btn.addEventListener('click', (e) => {
            e.preventDefault();
            if (flagged.has(q.id)) flagged.delete(q.id); else flagged.add(q.id);
            refresh();
            updateCountsAndNav();
          });

          titleRow.appendChild(btn);
          refresh();
        });
      }

      // Update counts when answers change or active question changes
      document.getElementById('testForm').addEventListener('change', () => updateCountsAndNav());
      document.addEventListener('qactivechange', () => updateCountsAndNav());

      buildNavigator();
      attachFlagButtons();
      setTimeout(() => { setActiveQuestion(0); updateCountsAndNav(); }, 60);

      // Restore any saved state (best-effort)
      async function restoreProgress() {
        if (!attemptId) return;
        try {
          const r = await fetch('/api/attempts/' + attemptId + '/state', { cache: 'no-store' });
          if (!r.ok) return;
          const st = await r.json();
          if (!st || !Array.isArray(st.answers)) return;

          // restore answers
          for (const a of st.answers) {
            const qid = a.question_id;
            const oid = a.option_id;
            const el = document.querySelector('input[name="q_' + qid + '"][value="' + oid + '"]');
            if (el) el.checked = true;
          }

          // restore flags
          if (Array.isArray(st.flagged)) {
            st.flagged.forEach(qid => flagged.add(qid));
          }

          // restore active question
          if (st.state && Number.isFinite(st.state.active_index)) {
            setActiveQuestion(st.state.active_index);
          }

          updateCountsAndNav();
          attachFlagButtons();

          setSaveStatus('Restored saved progress', '#94a3b8');
        } catch (e) {}
      }

      let _saveTimer = null;
      async function saveProgress() {
        if (!attemptId || isPractice) return;
        if (!navigator.onLine) {
          setSaveStatus('Offline — changes not saved', '#f59e0b');
          return;
        }
        setSaveStatus('Saving…', '#38bdf8');

        const payload = {
          remaining_seconds: Number.isFinite(window._remainingSeconds) ? window._remainingSeconds : null,
          active_index: _activeQ,
          answers: serializeAnswers(),
          flagged: Array.from(flagged.values())
        };

        try {
          const r = await fetch('/api/attempts/' + attemptId + '/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await r.json().catch(() => ({}));
          if (!r.ok) {
            setSaveStatus((data && data.error) ? ('Save failed: ' + data.error) : ('Save failed (' + r.status + ')'), '#ef4444');
            return;
          }
          setSaveStatus('Saved', '#22c55e');
        } catch (e) {
          setSaveStatus('Save failed (network)', '#ef4444');
        }
      }

      function scheduleSave() {
        if (_saveTimer) clearTimeout(_saveTimer);
        _saveTimer = setTimeout(saveProgress, 700);
      }

      document.getElementById('testForm').addEventListener('change', scheduleSave);
      document.addEventListener('qactivechange', scheduleSave);
      window.addEventListener('online', scheduleSave);

      // periodic autosave
      setInterval(() => {
        if (!attemptId || isPractice) return;
        saveProgress();
      }, 12000);

      restoreProgress();

      // Track focus to prompt save
      window.addEventListener('beforeunload', () => {
        try { if (attemptId && !isPractice) navigator.sendBeacon('/api/attempts/' + attemptId + '/save', new Blob([JSON.stringify({ remaining_seconds: window._remainingSeconds, active_index: _activeQ, answers: serializeAnswers(), flagged: Array.from(flagged.values()) })], { type: 'application/json' })); } catch(e) {}
      });


    }

    async function submitAnswers(auto = false) {
      const answers = [];
      document.querySelectorAll('[name^="q_"]').forEach(el => {
        if (el.checked) {
          const questionId = el.name.substring(2);
          answers.push({ question_id: parseInt(questionId), option_id: parseInt(el.value) });
        }
      });

      if (!auto && answers.length === 0) {
        alert('Answer at least one question.');
        return;
      }

      const payload = {
        attempt_id: attemptId, // Submit against the live attempt
        student_name: studentName,
        student_id: studentId,
        student_db_id: dbId ? parseInt(dbId) : null,
        answers
      };

      const res = await fetch(`/api/tests/${testId}/submit`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      const data = await res.json();
      if (data.error) { alert('Error: ' + data.error); return; }

      document.getElementById('result').style.display = 'block';

      // Summary chip
      const totalQuestions = getQuestionBlocks().length;
      const answeredNow = Number(document.getElementById('answeredCount')?.textContent || 0);
      const flaggedNow = Number(document.getElementById('flaggedCount')?.textContent || 0);
      const durationUsed = (typeof window._initialRemainingSeconds === 'number' && typeof window._remainingSeconds === 'number')
        ? Math.max(0, window._initialRemainingSeconds - window._remainingSeconds)
        : null;
      const minsUsed = durationUsed != null ? Math.floor(durationUsed / 60) : null;
      const secsUsed = durationUsed != null ? (durationUsed % 60) : null;
      const timeUsedText = durationUsed != null ? ` • Time used: ${String(minsUsed).padStart(2,'0')}:${String(secsUsed).padStart(2,'0')}` : '';

      document.getElementById('scoreText').textContent = `Score: ${data.score} / ${data.total} • Answered: ${answeredNow}/${totalQuestions} • Flagged: ${flaggedNow}${timeUsedText}`;

      // If in full-session mode, show a brief notice and redirect to next test automatically
      const nextNoticeEl = document.getElementById('nextExamNotice');
      if (sessionMode === 'full' && sessionOrder) {
        const ids = sessionOrder.split(',').map(x => parseInt(x, 10)).filter(Boolean);
        const currentIndex = ids.indexOf(parseInt(testId, 10));
        const nextId = currentIndex >= 0 && currentIndex + 1 < ids.length ? ids[currentIndex + 1] : null;
        if (nextId) {
          if (nextNoticeEl) {
            nextNoticeEl.textContent = 'Next exam starting shortly…';
            nextNoticeEl.style.display = 'block';
          }
          setTimeout(() => {
            const nextParams = new URLSearchParams({
              name: studentName,
              id: studentId,
              test: nextId,
              db_id: dbId || '',
              session: 'full',
              order: ids.join(',')
            });
            window.location.href = 'test.html?' + nextParams.toString();
          }, 3000);
        } else if (nextNoticeEl) {
          nextNoticeEl.style.display = 'none';
        }
      } else if (nextNoticeEl) {
        nextNoticeEl.style.display = 'none';
      }

      // Build review
      const reviewEl = document.getElementById('review');
      reviewEl.innerHTML = '';
      if (data.detailed) {
        data.detailed.forEach((item, idx) => {
          const block = document.createElement('div');
          block.className = 'review-block';
          const qEl = document.createElement('div');
          qEl.className = 'review-question';
          qEl.textContent = `${idx + 1}. ${item.question_text} (${item.marks} pts)`;
          block.appendChild(qEl);

          const line1 = document.createElement('div');
          line1.className = 'review-line';
          const you = document.createElement('span');
          const isCorrect = item.selected_option?.is_correct;
          you.innerHTML = `Your answer: <span class="${isCorrect ? 'badge-correct' : 'badge-wrong'}">${item.selected_option?.text || '—'}</span>`;
          line1.appendChild(you);
          block.appendChild(line1);

          if (item.correct_option) {
            const line2 = document.createElement('div');
            line2.className = 'review-line mt-1';
            const correct = document.createElement('span');
            correct.innerHTML = `Correct answer: <span class="badge-correct">${item.correct_option.text}</span>`;
            line2.appendChild(correct);
            block.appendChild(line2);
          }

          // Practice mode: show explanation (if any)
          if (isPractice && item.explanation) {
            const exp = document.createElement('div');
            exp.className = 'review-line mt-2';
            exp.style.color = '#e2e8f0';
            exp.style.opacity = '0.95';
            exp.innerHTML = `<span class="text-muted">Explanation:</span> ${String(item.explanation)}`;
            block.appendChild(exp);
          }

          reviewEl.appendChild(block);
        });
        reviewEl.style.display = 'block';
      }
      document.getElementById('submitBtn').disabled = true;
      if (window._timerInterval) clearInterval(window._timerInterval);
    }

    document.getElementById('submitBtn').addEventListener('click', () => submitAnswers(false));

    function showTimeWarning() {
      // Lightweight, non-blocking warning (no alert())
      if (document.getElementById('timeWarningBanner')) return;

      const banner = document.createElement('div');
      banner.id = 'timeWarningBanner';
      banner.style.position = 'sticky';
      banner.style.top = '0';
      banner.style.zIndex = '20';
      banner.style.margin = '10px 0 0';
      banner.style.padding = '10px 12px';
      banner.style.borderRadius = '12px';
      banner.style.border = '1px solid rgba(245, 158, 11, 0.35)';
      banner.style.background = 'rgba(245, 158, 11, 0.12)';
      banner.style.color = '#fde68a';
      banner.style.fontSize = '0.9rem';
      banner.style.display = 'flex';
      banner.style.alignItems = 'center';
      banner.style.justifyContent = 'space-between';
      banner.style.gap = '10px';
      banner.innerHTML = `
        <div><strong>5 minutes left.</strong> Please review your answers and submit.</div>
        <button id="dismissTimeWarning" type="button" class="btn btn-sm btn-outline-warning">Dismiss</button>
      `;

      const header = document.querySelector('.panel-header');
      if (header && header.parentNode) {
        header.parentNode.insertBefore(banner, header.nextSibling);
      } else {
        document.body.prepend(banner);
      }

      document.getElementById('dismissTimeWarning')?.addEventListener('click', () => banner.remove());

      // Optional: subtle beep (best-effort)
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.value = 880;
        g.gain.value = 0.03;
        o.connect(g);
        g.connect(ctx.destination);
        o.start();
        setTimeout(() => { o.stop(); ctx.close(); }, 160);
      } catch (e) {
        // ignore audio failures
      }
    }

    function startTimer(durationMinutes) {
      let remaining = durationMinutes * 60;
      window._remainingSeconds = remaining;
      window._initialRemainingSeconds = remaining;
      const timerEl = document.getElementById('timer');
      let warned5min = false;

      const render = () => {
        const m = Math.floor(remaining / 60);
        const s = remaining % 60;
        timerEl.textContent = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
      };
      render();
      window._timerInterval = setInterval(() => {
        remaining--;
        window._remainingSeconds = remaining;

        if (!warned5min && remaining === 5 * 60) {
          warned5min = true;
          showTimeWarning();
        }

        if (remaining <= 0) {
          clearInterval(window._timerInterval);
          timerEl.textContent = '00:00';
          submitAnswers(true);
        } else {
          render();
        }
      }, 1000);
    }

    document.getElementById('finishLogoutBtn').addEventListener('click', () => {
      localStorage.removeItem('cln_student_user');
      try { localStorage.removeItem('cln_last_session'); } catch (e) {}
      window.location.href = 'index.html';
    });


    // Connection status indicator (best-effort)
    function setConnStatus(state, extra='') {
      const el = document.getElementById('connStatus');
      if (!el) return;
      el.classList.remove('conn-green','conn-amber','conn-red');
      if (state === 'green') { el.classList.add('conn-green'); el.textContent = '● Online' + (extra ? (' · ' + extra) : ''); }
      else if (state === 'amber') { el.classList.add('conn-amber'); el.textContent = '● Slow' + (extra ? (' · ' + extra) : ''); }
      else { el.classList.add('conn-red'); el.textContent = '● Offline' + (extra ? (' · ' + extra) : ''); }
    }

    async function pingServer() {
      const t0 = performance.now();
      try {
        const r = await fetch('/api/health', { cache: 'no-store' });
        if (!r.ok) throw new Error('bad');
        const ms = Math.round(performance.now() - t0);
        if (!navigator.onLine) return setConnStatus('red');
        if (ms < 350) return setConnStatus('green', ms + 'ms');
        if (ms < 1200) return setConnStatus('amber', ms + 'ms');
        return setConnStatus('amber', ms + 'ms');
      } catch (e) {
        setConnStatus('red');
      }
    }

    window.addEventListener('online', () => pingServer());
    window.addEventListener('offline', () => setConnStatus('red'));
    setInterval(pingServer, 5000);
    pingServer();

    // Keyboard shortcuts + simple question navigation
    let _activeQ = 0;

    function getQuestionBlocks() {
      return Array.from(document.querySelectorAll('.question-block'));
    }

    function setActiveQuestion(idx) {
      const blocks = getQuestionBlocks();
      if (!blocks.length) return;
      _activeQ = Math.max(0, Math.min(idx, blocks.length - 1));
      blocks.forEach((b,i) => b.classList.toggle('question-active', i === _activeQ));
      blocks[_activeQ].scrollIntoView({ behavior: 'smooth', block: 'start' });
      document.dispatchEvent(new CustomEvent('qactivechange', { detail: { index: _activeQ } }));
    }

    function pickOptionByIndex(optIdx) {
      const blocks = getQuestionBlocks();
      const block = blocks[_activeQ];
      if (!block) return;
      const inputs = Array.from(block.querySelectorAll('input[type="radio"], input[type="checkbox"]'));
      const input = inputs[optIdx];
      if (!input) return;
      if (input.type === 'checkbox') {
        input.checked = !input.checked;
        input.dispatchEvent(new Event('change', { bubbles: true }));
      } else {
        input.checked = true;
        input.dispatchEvent(new Event('change', { bubbles: true }));
      }
    }

    document.addEventListener('click', (e) => {
      const block = e.target.closest?.('.question-block');
      if (!block) return;
      const blocks = getQuestionBlocks();
      const idx = blocks.indexOf(block);
      if (idx >= 0) setActiveQuestion(idx);
    });

    document.addEventListener('keydown', (e) => {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
      if (tag === 'input' || tag === 'textarea' || e.target?.isContentEditable) return;

      const k = e.key;
      if (k === 'n' || k === 'N') { e.preventDefault(); setActiveQuestion(_activeQ + 1); return; }
      if (k === 'p' || k === 'P') { e.preventDefault(); setActiveQuestion(_activeQ - 1); return; }

      const map = { '1':0,'2':1,'3':2,'4':3,'a':0,'A':0,'b':1,'B':1,'c':2,'C':2,'d':3,'D':3 };
      if (k in map) { e.preventDefault(); pickOptionByIndex(map[k]); return; }
    });

    // Clear stored resume marker when finishing/submitting
    function clearLastSessionMarker() {
      try { localStorage.removeItem('cln_last_session'); } catch (e) {}
    }

    const _origSubmitAnswers = submitAnswers;
    submitAnswers = async function(auto=false) {
      const r = await _origSubmitAnswers(auto);
      clearLastSessionMarker();
      return r;
    };

    // When redirecting to next exam in full-session mode, keep marker (so resume still works)

    loadQuestions();
  </script>
</body>
</html>
